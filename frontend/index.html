<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kenya Water Equity Globe Heatmap</title>
  <style>
    html, body {
      margin: 0;
      background: #0e1a2b;
      overflow: hidden;
      font-family: sans-serif;
    }
    svg {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    .tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div class="tooltip" id="tooltip"></div>
  <svg id="globe"></svg>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <script>
    const width = window.innerWidth;
    const height = window.innerHeight;

    const svg = d3.select("#globe");
    const tooltip = d3.select("#tooltip");

    const projection = d3.geoOrthographic()
      .scale(height / 2.3)
      .translate([width / 2, height / 2])
      .rotate([-33.5, -1]);

    const path = d3.geoPath(projection);

    const color = d3.scaleSequential(d3.interpolateYlGnBu)
      .domain([-0.1, 2.0]);

    const g = svg.append("g");

    g.append("circle")
      .attr("fill", "#081421")
      .attr("stroke", "#999")
      .attr("cx", width / 2)
      .attr("cy", height / 2)
      .attr("r", projection.scale());

    Promise.all([
      d3.json("https://unpkg.com/world-atlas@2.0.2/countries-110m.json"),
      d3.json("kenya_water_equity.json")
    ]).then(([world, data]) => {
      const countries = topojson.feature(world, world.objects.countries);

      
      const land = g.selectAll("path")
        .data(countries.features)
        .enter().append("path")
        .attr("fill", "#1e3d59")
        .attr("stroke", "#aaa")
        .attr("stroke-width", 0.3)
        .attr("d", path);

      
      const points = g.selectAll("circle.data-point")
        .data(data)
        .enter().append("circle")
        .attr("class", "data-point")
        .attr("r", 0)
        .attr("fill", d => color(d.score))
        .attr("stroke", "#fff")
        .attr("stroke-width", 0.2)
        .attr("opacity", 0)
        .on("mouseover", (event, d) => {
          tooltip.style("display", "block")
                 .style("left", (event.pageX + 10) + "px")
                 .style("top", (event.pageY - 10) + "px")
                 .html(`Lat: ${d.lat.toFixed(2)}, Lon: ${d.lon.toFixed(2)}<br>Score: ${d.score.toFixed(2)}`);
        })
        .on("mouseout", () => tooltip.style("display", "none"));

      
      function update() {
        land.attr("d", path);
        points
          .attr("cx", d => projection([d.lon, d.lat])[0])
          .attr("cy", d => projection([d.lon, d.lat])[1]);
      }

      
      function animatePoints() {
        points.transition()
          .delay((_, i) => i * 3)
          .duration(800)
          .attr("r", 3)
          .attr("opacity", 1);
      }

      
      let lastTime = Date.now();
      let paused = false;
      const rotateSpeed = 0.02;

      d3.timer(() => {
        if (!paused) {
          const now = Date.now();
          const diff = now - lastTime;
          const rotation = projection.rotate();
          rotation[0] += rotateSpeed * (diff / 16); 
          projection.rotate(rotation);
          update();
          lastTime = now;
        }
      });

      
      svg.call(d3.drag()
        .on("start", () => paused = true)
        .on("drag", event => {
          const rotate = projection.rotate();
          const k = 0.25;
          projection.rotate([rotate[0] + event.dx * k, rotate[1] - event.dy * k]);
          update();
        })
        .on("end", () => paused = false)
      );

      update();
      animatePoints();
    });
  </script>
</body>
</html>
